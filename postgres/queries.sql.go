// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteInboxMessage = `-- name: DeleteInboxMessage :exec
DELETE FROM inbox_message
WHERE recipient = $1
      AND id = $2
`

type DeleteInboxMessageParams struct {
	Recipient string
	ID        int64
}

func (q *Queries) DeleteInboxMessage(ctx context.Context, arg DeleteInboxMessageParams) error {
	_, err := q.db.Exec(ctx, deleteInboxMessage, arg.Recipient, arg.ID)
	return err
}

const deleteOldInboxMessages = `-- name: DeleteOldInboxMessages :exec
DELETE FROM inbox_message
WHERE created < now() - INTERVAL '6 months'
`

func (q *Queries) DeleteOldInboxMessages(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldInboxMessages)
	return err
}

const deleteOldMessages = `-- name: DeleteOldMessages :exec
DELETE FROM message
WHERE created < now() - INTERVAL '2 weeks'
`

func (q *Queries) DeleteOldMessages(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteOldMessages)
	return err
}

const getLatestInboxMessageId = `-- name: GetLatestInboxMessageId :one
SELECT COALESCE(MAX(id), 0)::bigint AS latest_id
FROM inbox_message
WHERE recipient = $1
`

func (q *Queries) GetLatestInboxMessageId(ctx context.Context, recipient string) (int64, error) {
	row := q.db.QueryRow(ctx, getLatestInboxMessageId, recipient)
	var latest_id int64
	err := row.Scan(&latest_id)
	return latest_id, err
}

const getLatestMessageId = `-- name: GetLatestMessageId :one
SELECT COALESCE(MAX(id), 0)::bigint AS latest_id
FROM message
WHERE recipient = $1
`

func (q *Queries) GetLatestMessageId(ctx context.Context, recipient string) (int64, error) {
	row := q.db.QueryRow(ctx, getLatestMessageId, recipient)
	var latest_id int64
	err := row.Scan(&latest_id)
	return latest_id, err
}

const getMessageWriteLock = `-- name: GetMessageWriteLock :one
SELECT recipient, message_type, current_message_id
FROM message_write_lock
WHERE recipient = $1
      AND message_type = $2
FOR UPDATE
`

type GetMessageWriteLockParams struct {
	Recipient   string
	MessageType string
}

func (q *Queries) GetMessageWriteLock(ctx context.Context, arg GetMessageWriteLockParams) (MessageWriteLock, error) {
	row := q.db.QueryRow(ctx, getMessageWriteLock, arg.Recipient, arg.MessageType)
	var i MessageWriteLock
	err := row.Scan(&i.Recipient, &i.MessageType, &i.CurrentMessageID)
	return i, err
}

const insertInboxMessage = `-- name: InsertInboxMessage :exec
INSERT INTO inbox_message(
      recipient, id, created, created_by, updated, is_read, payload
) VALUES (
      $1, $2, $3, $4, $5, $6, $7
)
`

type InsertInboxMessageParams struct {
	Recipient string
	ID        int64
	Created   pgtype.Timestamptz
	CreatedBy string
	Updated   pgtype.Timestamptz
	IsRead    bool
	Payload   []byte
}

func (q *Queries) InsertInboxMessage(ctx context.Context, arg InsertInboxMessageParams) error {
	_, err := q.db.Exec(ctx, insertInboxMessage,
		arg.Recipient,
		arg.ID,
		arg.Created,
		arg.CreatedBy,
		arg.Updated,
		arg.IsRead,
		arg.Payload,
	)
	return err
}

const insertMessage = `-- name: InsertMessage :exec
INSERT INTO message(
      recipient, id, type, created, created_by, doc_uuid, doc_type, payload
) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8
)
`

type InsertMessageParams struct {
	Recipient string
	ID        int64
	Type      pgtype.Text
	Created   pgtype.Timestamptz
	CreatedBy string
	DocUuid   pgtype.UUID
	DocType   pgtype.Text
	Payload   []byte
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) error {
	_, err := q.db.Exec(ctx, insertMessage,
		arg.Recipient,
		arg.ID,
		arg.Type,
		arg.Created,
		arg.CreatedBy,
		arg.DocUuid,
		arg.DocType,
		arg.Payload,
	)
	return err
}

const listInboxMessagesAfterId = `-- name: ListInboxMessagesAfterId :many
SELECT recipient, id, created, created_by, updated, is_read, payload
FROM inbox_message
WHERE recipient = $1
      AND id > $2
ORDER BY id ASC
LIMIT $3::bigint
`

type ListInboxMessagesAfterIdParams struct {
	Recipient string
	AfterID   int64
	Limit     int64
}

func (q *Queries) ListInboxMessagesAfterId(ctx context.Context, arg ListInboxMessagesAfterIdParams) ([]InboxMessage, error) {
	rows, err := q.db.Query(ctx, listInboxMessagesAfterId, arg.Recipient, arg.AfterID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InboxMessage
	for rows.Next() {
		var i InboxMessage
		if err := rows.Scan(
			&i.Recipient,
			&i.ID,
			&i.Created,
			&i.CreatedBy,
			&i.Updated,
			&i.IsRead,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInboxMessagesBeforeId = `-- name: ListInboxMessagesBeforeId :many
SELECT recipient, id, created, created_by, updated, is_read, payload
FROM inbox_message
WHERE recipient = $1
      AND ($2::bigint = 0 OR id < $2)
ORDER BY id DESC
LIMIT $3::bigint
`

type ListInboxMessagesBeforeIdParams struct {
	Recipient string
	BeforeID  int64
	Limit     int64
}

func (q *Queries) ListInboxMessagesBeforeId(ctx context.Context, arg ListInboxMessagesBeforeIdParams) ([]InboxMessage, error) {
	rows, err := q.db.Query(ctx, listInboxMessagesBeforeId, arg.Recipient, arg.BeforeID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InboxMessage
	for rows.Next() {
		var i InboxMessage
		if err := rows.Scan(
			&i.Recipient,
			&i.ID,
			&i.Created,
			&i.CreatedBy,
			&i.Updated,
			&i.IsRead,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesAfterId = `-- name: ListMessagesAfterId :many
SELECT recipient, id, type, created, created_by, doc_uuid, doc_type, payload
FROM message
WHERE recipient = $1
      AND id > $2
ORDER BY id ASC
LIMIT $3::bigint
`

type ListMessagesAfterIdParams struct {
	Recipient string
	AfterID   int64
	Limit     int64
}

func (q *Queries) ListMessagesAfterId(ctx context.Context, arg ListMessagesAfterIdParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessagesAfterId, arg.Recipient, arg.AfterID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.Recipient,
			&i.ID,
			&i.Type,
			&i.Created,
			&i.CreatedBy,
			&i.DocUuid,
			&i.DocType,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notify = `-- name: Notify :exec
SELECT pg_notify($1::text, $2::text)
`

type NotifyParams struct {
	Channel string
	Message string
}

func (q *Queries) Notify(ctx context.Context, arg NotifyParams) error {
	_, err := q.db.Exec(ctx, notify, arg.Channel, arg.Message)
	return err
}

const updateInboxMessage = `-- name: UpdateInboxMessage :exec
UPDATE inbox_message
SET is_read = $1
WHERE recipient = $2
      AND id = $3
`

type UpdateInboxMessageParams struct {
	IsRead    bool
	Recipient string
	ID        int64
}

func (q *Queries) UpdateInboxMessage(ctx context.Context, arg UpdateInboxMessageParams) error {
	_, err := q.db.Exec(ctx, updateInboxMessage, arg.IsRead, arg.Recipient, arg.ID)
	return err
}

const upsertMessageWriteLock = `-- name: UpsertMessageWriteLock :exec
INSERT INTO message_write_lock(
      recipient, message_type, current_message_id
) VALUES (
      $1, $2, $3
)
ON CONFLICT(recipient, message_type)
DO UPDATE
SET current_message_id = EXCLUDED.current_message_id
`

type UpsertMessageWriteLockParams struct {
	Recipient        string
	MessageType      string
	CurrentMessageID pgtype.Int8
}

func (q *Queries) UpsertMessageWriteLock(ctx context.Context, arg UpsertMessageWriteLockParams) error {
	_, err := q.db.Exec(ctx, upsertMessageWriteLock, arg.Recipient, arg.MessageType, arg.CurrentMessageID)
	return err
}

const upsertUser = `-- name: UpsertUser :exec
INSERT INTO "user"(
      sub, created
) VALUES (
      $1, $2
)
ON CONFLICT (sub)
DO NOTHING
`

type UpsertUserParams struct {
	Sub     string
	Created pgtype.Timestamptz
}

func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) error {
	_, err := q.db.Exec(ctx, upsertUser, arg.Sub, arg.Created)
	return err
}

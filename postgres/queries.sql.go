// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getMessageWriteLock = `-- name: GetMessageWriteLock :one
SELECT recipient, message_type, current_message_id
FROM message_write_lock
WHERE recipient = $1
      AND message_type = $2
FOR UPDATE
`

type GetMessageWriteLockParams struct {
	Recipient   string
	MessageType string
}

func (q *Queries) GetMessageWriteLock(ctx context.Context, arg GetMessageWriteLockParams) (MessageWriteLock, error) {
	row := q.db.QueryRow(ctx, getMessageWriteLock, arg.Recipient, arg.MessageType)
	var i MessageWriteLock
	err := row.Scan(&i.Recipient, &i.MessageType, &i.CurrentMessageID)
	return i, err
}

const insertInboxMessage = `-- name: InsertInboxMessage :exec
INSERT INTO inbox_message(
      recipient, id, created, created_by, updated, is_read, payload
) VALUES (
      $1, $2, $3, $4, $5, $6, $7
)
`

type InsertInboxMessageParams struct {
	Recipient string
	ID        int64
	Created   pgtype.Timestamptz
	CreatedBy string
	Updated   pgtype.Timestamptz
	IsRead    bool
	Payload   []byte
}

func (q *Queries) InsertInboxMessage(ctx context.Context, arg InsertInboxMessageParams) error {
	_, err := q.db.Exec(ctx, insertInboxMessage,
		arg.Recipient,
		arg.ID,
		arg.Created,
		arg.CreatedBy,
		arg.Updated,
		arg.IsRead,
		arg.Payload,
	)
	return err
}

const insertMessage = `-- name: InsertMessage :exec
INSERT INTO message(
      recipient, id, type, created, created_by, doc_uuid, doc_type, payload
) VALUES (
      $1, $2, $3, $4, $5, $6, $7, $8
)
`

type InsertMessageParams struct {
	Recipient string
	ID        int64
	Type      pgtype.Text
	Created   pgtype.Timestamptz
	CreatedBy string
	DocUuid   pgtype.UUID
	DocType   pgtype.Text
	Payload   []byte
}

func (q *Queries) InsertMessage(ctx context.Context, arg InsertMessageParams) error {
	_, err := q.db.Exec(ctx, insertMessage,
		arg.Recipient,
		arg.ID,
		arg.Type,
		arg.Created,
		arg.CreatedBy,
		arg.DocUuid,
		arg.DocType,
		arg.Payload,
	)
	return err
}

const listInboxMessages = `-- name: ListInboxMessages :many
SELECT recipient, id, created, created_by, updated, is_read, payload
FROM inbox_message
WHERE recipient = $1
      AND ($2::bigint = 0 OR id < $2)
ORDER BY id DESC
LIMIT $3::bigint
`

type ListInboxMessagesParams struct {
	Recipient string
	BeforeID  int64
	Limit     int64
}

func (q *Queries) ListInboxMessages(ctx context.Context, arg ListInboxMessagesParams) ([]InboxMessage, error) {
	rows, err := q.db.Query(ctx, listInboxMessages, arg.Recipient, arg.BeforeID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InboxMessage
	for rows.Next() {
		var i InboxMessage
		if err := rows.Scan(
			&i.Recipient,
			&i.ID,
			&i.Created,
			&i.CreatedBy,
			&i.Updated,
			&i.IsRead,
			&i.Payload,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const notify = `-- name: Notify :exec
SELECT pg_notify($1::text, $2::text)
`

type NotifyParams struct {
	Channel string
	Message string
}

func (q *Queries) Notify(ctx context.Context, arg NotifyParams) error {
	_, err := q.db.Exec(ctx, notify, arg.Channel, arg.Message)
	return err
}

const upsertMessageWriteLock = `-- name: UpsertMessageWriteLock :exec
INSERT INTO message_write_lock(
      recipient, message_type, current_message_id
) VALUES (
      $1, $2, $3
)
ON CONFLICT(recipient, message_type)
DO UPDATE
SET current_message_id = EXCLUDED.current_message_id
`

type UpsertMessageWriteLockParams struct {
	Recipient        string
	MessageType      string
	CurrentMessageID pgtype.Int8
}

func (q *Queries) UpsertMessageWriteLock(ctx context.Context, arg UpsertMessageWriteLockParams) error {
	_, err := q.db.Exec(ctx, upsertMessageWriteLock, arg.Recipient, arg.MessageType, arg.CurrentMessageID)
	return err
}
